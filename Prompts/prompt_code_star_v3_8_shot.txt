Below are eight examples that demonstrate the desired style:

<EXAMPLE 1>
<Premises>
Peter Parker is either a superhero or a civilian.
The Hulk is a destroyer.
The Hulk wakes up when he is angry.
If the Hulk wakes up, then he will break a bridge.
Thor is a god.
Thor will break a bridge when he is happy.
A god is not a destroyer.
Peter Parker wears a uniform when he is a superhero.
Peter Parker is not a civilian if a destroyer is breaking a bridge.
If Thor is happy, the Hulk is angry.
</Premises>
<Conclusion>
If Thor is happy, then Peter Parker wears a uniform.
</Conclusion>
<Question>
Is the following statement true, false, or uncertain? If Thor is happy, then Peter Parker wears a uniform.
</Question> 
<Options>
(A) True
(B) False
(C) Uncertain
</Options>
<Reasoning>
<PYTHON>
from typing import Optional

class Hulk:
    def __init__(self, angry: Optional[bool] = None):
        self.angry = angry  # can be True, False, or None

    @property
    def is_destroyer(self) -> bool:
        return True  # Premise: The Hulk is a destroyer.

    @property
    def wakes_up(self) -> Optional[bool]:
        # Premise: The Hulk wakes up when he is angry.
        if self.angry is None:
            return None
        return self.angry

    @property
    def breaks_bridge(self) -> Optional[bool]:
        # Premise: If the Hulk wakes up, then he will break a bridge.
        if self.wakes_up is None:
            return None
        return self.wakes_up

class Thor:
    def __init__(self, happy: Optional[bool] = None):
        self.happy = happy  # can be True, False, or None

    @property
    def is_god(self) -> bool:
        return True  # Premise: Thor is a god.

    @property
    def is_destroyer(self) -> bool:
        # Premise: A god is not a destroyer.
        return False

    @property
    def breaks_bridge(self) -> Optional[bool]:
        # Premise: Thor will break a bridge when he is happy.
        if self.happy is None:
            return None
        return self.happy

class PeterParker:
    def __init__(self, is_superhero: Optional[bool] = None):
        self.is_superhero = is_superhero  # True: superhero, False: civilian, None: unknown

    @property
    def is_civilian(self) -> Optional[bool]:
        # Premise: Peter Parker is either a superhero or a civilian.
        if self.is_superhero is None:
            return None
        return not self.is_superhero

    @property
    def wears_uniform(self) -> Optional[bool]:
        # Premise: Peter Parker wears a uniform when he is a superhero.
        if self.is_superhero is None:
            return None
        return self.is_superhero

def apply_premises(thor: Thor, hulk: Hulk, peter: PeterParker) -> bool:
    changed = False

    # Premise 10: If Thor is happy, then the Hulk is angry.
    if thor.happy is True and hulk.angry is not True:
        hulk.angry = True
        changed = True

    # Premise 4 is encoded in Hulk.breaks_bridge.
    # Premise 9: If a destroyer is breaking a bridge, then Peter Parker is not a civilian,
    # meaning he must be a superhero.
    if hulk.is_destroyer and hulk.breaks_bridge is True and peter.is_superhero is not True:
        peter.is_superhero = True
        changed = True

    return changed

def run_inference(thor: Thor, hulk: Hulk, peter: PeterParker):
    while apply_premises(thor, hulk, peter):
        pass

def check_conclusion(thor: Thor, hulk: Hulk, peter: PeterParker) -> str:
    run_inference(thor, hulk, peter)
    if thor.happy is True:
        if peter.wears_uniform is True:
            return "True"
        elif peter.wears_uniform is False:
            return "False"
        else:
            return "Uncertain"
    else:
        # If Thor is not happy, the implication is vacuously true.
        return "True"

def func():
    # Initial conditions:
    # Peter Parker is either a superhero or a civilian.
    # Here we assume initially he is a civilian (is_superhero = False).
    # The Hulk's anger is initially unknown (set to False for determinism).
    thor = Thor(happy=True)       # Premise: Thor is happy.
    hulk = Hulk(angry=False)        # Initial state; will be updated by inference.
    peter = PeterParker(is_superhero=False)  # Initially a civilian.
    return check_conclusion(thor, hulk, peter)

if __name__ == '__main__':
    result = func()
    print("Conclusion: If Thor is happy, then Peter Parker wears a uniform?", result)
</PYTHON>
Therefore, the answer is (A).
</Reasoning>
<Answer>
The final answer is (A).
</Answer>
</EXAMPLE 1>

<EXAMPLE 2>
<Premises>
All philosophers reason.
Some sophists reason.
All who can reason can distinguish truth from falsehood.
Nobody who can distinguish truth from falsehood is morally perfect.
The theistic God is morally perfect.
The theistic God is a sophist.
</Premises>
<Conclusion>
The theistic God is a sophist and a philosopher.
</Conclusion>
<Question>
Is the following statement true, false, or uncertain? The theistic God is a sophist and a philosopher.
</Question>
<Options>
(A) True
(B) False
(C) Uncertain
</Options>
<Reasoning>
<PYTHON>
from typing import Optional

class TheisticGod:
    def __init__(self,
                 is_philosopher: Optional[bool] = None,
                 is_sophist: Optional[bool] = None,
                 can_reason: Optional[bool] = None,
                 can_distinguish: Optional[bool] = None,
                 is_morally_perfect: Optional[bool] = None):
        self.is_philosopher = is_philosopher       # Unknown initially
        self.is_sophist = is_sophist               # Given (Premise 6)
        self.can_reason = can_reason               # Unknown initially
        self.can_distinguish = can_distinguish     # Unknown initially
        self.is_morally_perfect = is_morally_perfect # Given (Premise 5)

def apply_premises(god: TheisticGod) -> bool:
    changed = False

    # Premise 1: All philosophers reason.
    if god.is_philosopher is True and god.can_reason is not True:
        god.can_reason = True
        changed = True

    # Contrapositive of Premise 1: If one does not reason, then one is not a philosopher.
    if god.can_reason is False and god.is_philosopher is not False:
        god.is_philosopher = False
        changed = True

    # Premise 3: All who can reason can distinguish truth from falsehood.
    if god.can_reason is True and god.can_distinguish is not True:
        god.can_distinguish = True
        changed = True

    # Contrapositive of Premise 3: If one cannot distinguish truth from falsehood, then one cannot reason.
    if god.can_distinguish is False and god.can_reason is not False:
        god.can_reason = False
        changed = True

    # Premise 4: Nobody who can distinguish truth from falsehood is morally perfect.
    if god.can_distinguish is True and god.is_morally_perfect is not False:
        god.is_morally_perfect = False
        changed = True

    # Contrapositive of Premise 4: If one is morally perfect, then one cannot distinguish truth from falsehood.
    if god.is_morally_perfect is True and god.can_distinguish is not False:
        god.can_distinguish = False
        changed = True

    # Premise 2: Some sophists reason.
    # This only tells us that at least one sophist reasons,
    # so it does not force that all sophists (including God) must reason.
    # Premises 5 and 6 are given.

    return changed

def run_inference(god: TheisticGod):
    while apply_premises(god):
        pass

def check_conclusion(god: TheisticGod) -> str:
    run_inference(god)
    # Conclusion: The theistic God is a sophist and a philosopher.
    # if is_sophist or is_philosopher is None, then Uncertain
    if god.is_sophist is None or god.is_philosopher is None:
        return "Uncertain"
    if god.is_sophist is True and god.is_philosopher is True:
        return "True"
    else:
        return "False"

def func():
    # Premise 5: God is morally perfect -> True
    # Premise 6: God is a sophist -> True
    god = TheisticGod(
        is_philosopher=None,
        is_sophist=True,
        can_reason=None,
        can_distinguish=None,
        is_morally_perfect=True
    )
    return check_conclusion(god)

if __name__ == '__main__':
    result = func()
    print("Conclusion: The theistic God is a sophist and a philosopher?", result)

</PYTHON>
Therefore, the answer is (B).
</Reasoning>
<Answer>
The final answer is (B).
</Answer>
</EXAMPLE 2>

<EXAMPLE 3>
<Premises>
William Dickinson was a British politician who sat in the House of Commons William Dickinson attended Westminster school for high school and then the University of Edinburgh. 
The University of Edinburgh is a university located in the United Kingdom. 
William Dickinson supported the Portland Whigs. 
People who supported the Portland Whigs did not get a seat in the Parliament.
</Premises>
<Conclusion>
William Dickinson went to schools located in the United Kingdom for both high school and university.
</Conclusion>
<Question>
Is the following statement true, false, or uncertain? William Dickinson went to schools located in the United Kingdom for both high school and university.
</Question> 
<Options>
(A) True
(B) False
(C) Uncertain
</Options>
<Reasoning>
<PYTHON>
from typing import Optional

class School:
    def __init__(self, name: str, location: Optional[str] = None):
        self.name = name
        self.location = location

class University(School):
    pass

class Person:
    def __init__(self,
                 name: str,
                 is_british: Optional[bool] = None,
                 high_school: Optional[School] = None,
                 university: Optional[School] = None,
                 sat_in_house: Optional[bool] = None,
                 supported_portland_whigs: Optional[bool] = None):
        self.name = name
        self.is_british = is_british
        self.high_school = high_school
        self.university = university
        self.sat_in_house = sat_in_house
        self.supported_portland_whigs = supported_portland_whigs

def apply_premises(person: Person) -> bool:
    changed = False

    # Premise 1: William Dickinson was a British politician who sat in the House of Commons.
    if person.name == "William Dickinson":
        if person.is_british is None:
            person.is_british = True
            changed = True
        if person.sat_in_house is None:
            person.sat_in_house = True
            changed = True

    # Premise 2: William Dickinson attended Westminster School for high school and then the University of Edinburgh.
    if person.name == "William Dickinson":
        if person.high_school is None:
            person.high_school = School("Westminster School", location=None)
            changed = True
        if person.university is None:
            person.university = University("University of Edinburgh", location=None)
            changed = True

    # Premise 3: The University of Edinburgh is a university located in the United Kingdom.
    if person.university is not None and person.university.name == "University of Edinburgh":
        if person.university.location != "UK":
            person.university.location = "UK"
            changed = True

    # Premise 4: William Dickinson supported the Portland Whigs.
    if person.name == "William Dickinson":
        if person.supported_portland_whigs is None:
            person.supported_portland_whigs = True
            changed = True

    # Premise 5: People who supported the Portland Whigs did not get a seat in the Parliament.
    # (No update is made here as it does not affect school location.)
    return changed

def run_inference(person: Person):
    while apply_premises(person):
        pass

def check_conclusion(person: Person) -> str:
    run_inference(person)
    # Conclusion: William Dickinson went to schools located in the UK for both high school and university.
    if person.high_school is None or person.university is None:
        return "Uncertain"
    hs_loc = person.high_school.location
    uni_loc = person.university.location
    if hs_loc is None or uni_loc is None:
        return "Uncertain"
    if hs_loc == "UK" and uni_loc == "UK":
        return "True"
    else:
        return "False"

def func():
    person = Person(
        name="William Dickinson",
        is_british=None,
        high_school=None,
        university=None,
        sat_in_house=None,
        supported_portland_whigs=None
    )
    return check_conclusion(person)

if __name__ == '__main__':
    result = func()
    print("Conclusion: William Dickinson went to schools located in the UK for both high school and university?", result)
</PYTHON>
Therefore, the answer is (C).
</Reasoning>
<Answer>
The final answer is (C).
</Answer>
</EXAMPLE 3>


<EXAMPLE 4>
<Premises>
All of Michael's neighbors who grow their own fresh vegetables in their home gardens also have ample space.
All of Michael's neighbors who are young working professionals and live in large cities, do not have ample space.
All of Michael's neighbors who order takeout from delivery services often grow their own fresh vegetables in their home garden.
All of Michael's neighbors who enjoy going out often to restaurants with friends order takeout from delivery services often.
All of Michael's neighbors who regularly tout the benefits of homegrown and homecooked meals over fast food enjoy going out often to restaurants with friends.
Peter, Michael's neighbor, grows his own fresh vegetables in his home garden, or regularly touts the benefits of homegrown and homecooked meals over fast food, or both.
</Premises>
<Conclusion>
Peter is a young working professional who lives in large cities.
</Conclusion>
<Question>
Is the following statement true, false, or uncertain? Peter is a young working professional who lives in large cities.
</Question> 
<Options>
(A) True
(B) False
(C) Uncertain
</Options>
<Reasoning>
<PYTHON>
from typing import Optional, List

class Person:
    def __init__(self, name: str, grows_vegetables: Optional[bool] = None,
                 has_ample_space: Optional[bool] = None,
                 is_young_professional: Optional[bool] = None,
                 lives_in_large_city: Optional[bool] = None,
                 orders_takeout: Optional[bool] = None,
                 enjoys_restaurants: Optional[bool] = None,
                 touts_homegrown_food: Optional[bool] = None):
        self.name = name
        self.grows_vegetables = grows_vegetables
        self.has_ample_space = has_ample_space
        self.is_young_professional = is_young_professional
        self.lives_in_large_city = lives_in_large_city
        self.orders_takeout = orders_takeout
        self.enjoys_restaurants = enjoys_restaurants
        self.touts_homegrown_food = touts_homegrown_food
        self.neighbors: List['Person'] = []

    def add_neighbor(self, neighbor: 'Person'):
        self.neighbors.append(neighbor)

def apply_premises_conclusion(people) -> str:
    # Only consider one neighbor peter
    person = people.neighbors[0]
    assert person.name == "Peter", f"Expected name 'Peter', but got " + person

    # apply Premise 5
    if person.touts_homegrown_food:
        person.enjoys_restaurants = True
    # apply Premise 4
    if person.enjoys_restaurants:
        person.orders_takeout = True
    
    # apply Premise 3
    if person.orders_takeout:
        person.grows_vegetables = True

    # apply premise 1 
    if person.grows_vegetables:
        person.has_ample_space = True
    
    # apply premise 2 person.is_young_professional = False or person.lives_in_large_city = False, Conclusion: person.is_young_professional and person.lives_in_large_city
    if person.has_ample_space is True:
        conclusion = "False"
    return conclusion
    
def run_inference(people: List[Person]) -> str:
    return apply_premises_conclusion(people)

def check_conclusion(person: Person) -> str:
    return run_inference(person)

def func():
    michael = Person(name="Michael")
    peter_cases = [
        Person(name="Peter", grows_vegetables=True, touts_homegrown_food=True),
        Person(name="Peter", grows_vegetables=True, touts_homegrown_food=False),
        Person(name="Peter", grows_vegetables=False, touts_homegrown_food=True)
    ]

    results = []
    for i, peter in enumerate(peter_cases, start=1):
        michael.add_neighbor(peter)
        peter.add_neighbor(michael)
        result = check_conclusion(michael)
        results.append(result)
        michael.neighbors = []
    if all(r == "True" for r in results):
        result = "True"
    elif all(r == "False" for r in results):
        result = "False"
    else:
        result = "Uncertain"
    return result

if __name__ == "__main__":
    result = func()
    print("Conclusion:", result)                                                                                                                                                  1,28          Top
</PYTHON>
Therefore, the answer is (B).
</Reasoning>
<Answer>
The final answer is (B).
</Answer>
</EXAMPLE 4>

<EXAMPLE 5>
<Premises>
All functions that represent straight lines on the coordinate plane are linear functions.
No linear functions are non-convex functions.
A function is either a non-convex fuction or a convex function.
All quasi-convex functions are real-valued functions.
All convex functions are quasi-convex functions.
The maximum of quasiconvex functions is a function.
The maximum of quasiconvex functions is a function that represents straight lines on the coordinate plane or it is a convex function or it is not a non-convex function.
</Premises>
<Conclusion>
The maximum of quasiconvex functions is a quasi-convex function or it is not a real-valued function.
</Conclusion>
<Question>
Is the following statement true, false, or uncertain? The maximum of quasiconvex functions is a quasi-convex function or it is not a real-valued function.
</Question> 
<Options>
(A) True
(B) False
(C) Uncertain
</Options>
<Reasoning>
<PYTHON>
from typing import Optional, List

class Function:
    def __init__(self,
                 represents_straight_line: Optional[bool] = None,
                 is_linear: Optional[bool] = None,
                 is_convex: Optional[bool] = None,
                 is_non_convex: Optional[bool] = None,
                 is_quasiconvex: Optional[bool] = None,
                 is_real_valued: Optional[bool] = None):
        self.represents_straight_line = represents_straight_line
        self.is_linear = is_linear
        self.is_convex = is_convex
        self.is_non_convex = is_non_convex
        self.is_quasiconvex = is_quasiconvex
        self.is_real_valued = is_real_valued

def apply_premises(func: Function) -> None:
    # Premise 1: All functions that represent straight lines are linear.
    if func.represents_straight_line is True:
        func.is_linear = True
    # Premise 2: No linear functions are non-convex.
    if func.is_linear is True:
        func.is_non_convex = False
    # Premise 3: A function is either non-convex or convex.
    # If a function is not non-convex, we assume it is convex.
    if func.is_non_convex is False:
        func.is_convex = True
    elif func.is_convex is False:
        func.is_non_convex = True
    # Premise 4: All quasi-convex functions are real-valued.
    if func.is_quasiconvex is True:
        func.is_real_valued = True
    # Premise 5: All convex functions are quasi-convex.
    if func.is_convex is True:
        func.is_quasiconvex = True

def maximum_of_quasiconvex_functions(funcs: List[Function]) -> Function:
    # Premise 6: The maximum of quasi-convex functions is a function.
    max_func = Function()
    # Premise 7: The maximum of quasi-convex functions is either:
    # a function that represents straight lines, or is convex, or is not non-convex.
    # For demonstration, we set it to represent straight lines.
    max_func.represents_straight_line = True
    apply_premises(max_func)
    return max_func

def check_conclusion(max_func: Function) -> str:
    # Conclusion: The maximum of quasi-convex functions is a quasi-convex function or it is not a real-valued function.
    if max_func.is_quasiconvex is True or max_func.is_real_valued is False:
        return "True"
    elif max_func.is_quasiconvex is False and max_func.is_real_valued is True:
        return "False"
    else:
        return "Uncertain"

def func():
    # Create some dummy quasi-convex functions (all are real-valued by Premise 4)
    f1 = Function(is_quasiconvex=True, is_real_valued=True)
    f2 = Function(is_quasiconvex=True, is_real_valued=True)
    f3 = Function(is_quasiconvex=True, is_real_valued=True)
    funcs = [f1, f2, f3]
    max_func = maximum_of_quasiconvex_functions(funcs)
    result = check_conclusion(max_func)
    return result

if __name__ == "__main__":
    result = func()
    print("Conclusion:", result)
</PYTHON>
Therefore, the answer is (A).
</Reasoning>
<Answer>
The final answer is (A).
</Answer>
</EXAMPLE 5>


<EXAMPLE 6>
<Premises>
If Emily's friends publish journals, then they do not work in the entertainment industry.
All of Emily's friends who are award-winning novelists publish journals.
Emily's friends work in the entertainment industry or are highly acclaimed in their profession.
If Emily's friends are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.
If Emily's friends are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.
Taylor is Emily's friend.
It is not true that Taylor both holds highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace.
</Premises>
<Conclusion>
Taylor is Emily's friend and she often holds tenured and high-ranking positions at her workplace.
</Conclusion>
<Question>
Is the following statement true, false, or uncertain? Taylor is Emily's friend and she often holds tenured and high-ranking positions at her workplace.
</Question>
<Options>
(A) True
(B) False
(C) Uncertain
</Options>
<Reasoning>
<PYTHON>
from typing import Optional, List

class EmilyFriend:
    def __init__(self,
                 name: str,
                 publishes_journals: Optional[bool] = None,
                 works_in_entertainment: Optional[bool] = None,
                 award_winning_novelist: Optional[bool] = None,
                 highly_acclaimed: Optional[bool] = None,
                 holds_tenured_positions: Optional[bool] = None,
                 receives_glowing_feedback: Optional[bool] = None):
        self.name = name
        self.publishes_journals = publishes_journals
        self.works_in_entertainment = works_in_entertainment
        self.award_winning_novelist = award_winning_novelist
        self.highly_acclaimed = highly_acclaimed
        self.holds_tenured_positions = holds_tenured_positions
        self.receives_glowing_feedback = receives_glowing_feedback

def apply_premises(friend: EmilyFriend) -> None:
    if friend.award_winning_novelist is True:
        friend.publishes_journals = True
    if friend.publishes_journals is True:
        friend.works_in_entertainment = False
    # Premise: Friends work in entertainment or are highly acclaimed.
    if friend.works_in_entertainment is not True and friend.highly_acclaimed is not True:
        friend.works_in_entertainment = True
    if friend.highly_acclaimed is True:
        friend.holds_tenured_positions = True
        friend.receives_glowing_feedback = True
    # Premise: It is not true that a friend both is highly acclaimed and holds tenured positions.
    if friend.highly_acclaimed is True and friend.holds_tenured_positions is True:
        friend.highly_acclaimed = False

def check_conclusion(friend: EmilyFriend) -> str:
    apply_premises(friend)
    if friend.holds_tenured_positions is True:
        return "True"
    elif friend.holds_tenured_positions is False:
        return "False"
    else:
        return "Uncertain"

def func() -> str:
    cases: List[EmilyFriend] = []
    # Case A:
    # Taylor is not award-winning, does not publish journals, works in entertainment,
    # is not highly acclaimed, and does not hold tenured positions.
    case_a = EmilyFriend(
        name="Taylor",
        award_winning_novelist=False,
        publishes_journals=False,
        works_in_entertainment=True,
        highly_acclaimed=False,
        holds_tenured_positions=False
    )
    cases.append(case_a)
    
    # Case B:
    # Taylor is not award-winning, does not publish journals, works in entertainment,
    # is not highly acclaimed, but holds tenured positions.
    case_b = EmilyFriend(
        name="Taylor",
        award_winning_novelist=False,
        publishes_journals=False,
        works_in_entertainment=True,
        highly_acclaimed=False,
        holds_tenured_positions=True
    )
    cases.append(case_b)
    
    # Case C:
    # Taylor is award-winning (forcing her to publish journals, then not work in entertainment),
    # initially set as highly acclaimed, which would force her to hold tenured positions;
    # however, due to the conflict, highly_acclaimed is reset to False.
    # Final outcome: holds_tenured_positions remains True.
    case_c = EmilyFriend(
        name="Taylor",
        award_winning_novelist=True,
        publishes_journals=None,
        works_in_entertainment=None,
        highly_acclaimed=True,
        holds_tenured_positions=False  # initial value; will be updated
    )
    cases.append(case_c)
    
    results = []
    for c in cases:
        res = check_conclusion(c)
        results.append(res)
    
    if all(r == "True" for r in results):
        return "True"
    elif all(r == "False" for r in results):
        return "False"
    else:
        return "Uncertain"

if __name__ == "__main__":
    result = func()
    print("Conclusion:", result)

</PYTHON>
Therefore, the answer is (C).
</Reasoning>
<Answer>
The final answer is (C).
</Answer>
</EXAMPLE 6>


<EXAMPLE 7>
<Premises>
Everything in Size Town is big or small.
All big things in Size Town are heavy.
All small things in Size Town are light.
All heavy things in Size Town are still.
All light things in Size Town are unstable.
All unstable things in Size Town are changing.
All unstable things in Size Town are unpredictable.
The bird is in Size Town and it is not both heavy and still.
</Premises>
<Conclusion>
The bird is still.
</Conclusion>
<Question>
Is the following statement true, false, or uncertain? The bird is still.
</Question>
<Options>
(A) True
(B) False
(C) Uncertain
</Options>
<Reasoning>
<PYTHON>
from typing import Optional, List

class SizeTownObject:
    def __init__(self,
                 name: str,
                 is_big: Optional[bool] = None,   # True means big; False means small
                 heavy: Optional[bool] = None,
                 still: Optional[bool] = None,
                 light: Optional[bool] = None,
                 unstable: Optional[bool] = None,
                 changing: Optional[bool] = None,
                 unpredictable: Optional[bool] = None):
        self.name = name
        self.is_big = is_big
        self.heavy = heavy
        self.still = still
        self.light = light
        self.unstable = unstable
        self.changing = changing
        self.unpredictable = unpredictable
        self.inconsistent: Optional[bool] = None

def apply_premises(obj: SizeTownObject) -> None:
    # Premise 1: Everything in Size Town is big or small.
    # (We assume obj.is_big is preset to either True (big) or False (small).)
    
    # Premise 2: All big things are heavy.
    if obj.is_big is True:
        obj.heavy = True
        
    # Premise 3: All small things are light.
    if obj.is_big is False:
        obj.light = True
        
    # Premise 4: All heavy things are still.
    if obj.heavy is True:
        obj.still = True
        
    # Premise 5: All light things are unstable.
    if obj.light is True:
        obj.unstable = True
        
    # Premise 6: All unstable things are changing.
    if obj.unstable is True:
        obj.changing = True
        
    # Premise 7: All unstable things are unpredictable.
    if obj.unstable is True:
        obj.unpredictable = True
        
    # Premise 8: The bird is not both heavy and still.
    # If an object is both heavy and still, mark it as inconsistent.
    if obj.heavy is True and obj.still is True:
        obj.inconsistent = True
    else:
        obj.inconsistent = False

def check_conclusion(obj: SizeTownObject) -> str:
    apply_premises(obj)
    # If the object is inconsistent (i.e. it violates Premise 8), we treat the outcome as ambiguous.
    if obj.inconsistent:
        return "Uncertain"
    # Otherwise, if still is explicitly True, conclude "True".
    if obj.still is True:
        return "True"
    # If still is explicitly False, conclude "False".
    if obj.still is False:
        return "False"
    return "Uncertain"

def func() -> str:
    cases: List[SizeTownObject] = []
    # Case 1: Bird is set as big.
    # Then by Premises 2 and 4, heavy and still become True,
    # but this violates Premise 8 → outcome: Inconsistent.
    case1 = SizeTownObject(name="Bird", is_big=True)
    cases.append(case1)
    
    # Case 2: Bird is set as small.
    # Then by Premise 3, light becomes True; by Premise 5, unstable becomes True;
    # still remains undefined → outcome: Uncertain.
    case2 = SizeTownObject(name="Bird", is_big=False)
    cases.append(case2)
    
    results = [check_conclusion(case) for case in cases]
    
    if all(r == "True" for r in results):
        return "True"
    elif all(r == "False" for r in results):
        return "False"
    else:
        return "Uncertain"

if __name__ == "__main__":
    result = func()
    print("Conclusion:", result)
</PYTHON>
Therefore, the answer is (C).
</Reasoning>
<Answer>
The final answer is (C).
</Answer>
</EXAMPLE 7>


<EXAMPLE 8>
<Premises>
Any convicted criminal that is innocent is not truly guilty.
All convicted criminals who did not commit a crime are truly innocent.
All convicted criminals are truly guilty or found guilty.
If a convicted criminal is found guilty, then they are sentenced to a punishment.
If a convicted criminal is found guilty, then they can argue against their punishment.
Garry is a convicted criminal who not found guilty or is sentenced to punishment.
</Premises>
<Conclusion>
Garry is not both innocent and someone who did not commit a crime.
</Conclusion>
<Question>
Is the following statement true, false, or uncertain? Garry is not both innocent and someone who did not commit a crime.
</Question>
<Options>
(A) True
(B) False
(C) Uncertain
</Options>
<Reasoning>
<PYTHON>
from typing import Optional, List

class ConvictedCriminal:
    def __init__(self,
                 name: str,
                 innocent: Optional[bool] = None,
                 did_not_commit: Optional[bool] = None,
                 truly_guilty: Optional[bool] = None,
                 found_guilty: Optional[bool] = None,
                 sentenced: Optional[bool] = None,
                 can_argue: Optional[bool] = None):
        self.name = name
        self.innocent = innocent
        self.did_not_commit = did_not_commit
        self.truly_guilty = truly_guilty
        self.found_guilty = found_guilty
        self.sentenced = sentenced
        self.can_argue = can_argue

def apply_premises(criminal: ConvictedCriminal) -> None:
    # Premise 2: All criminals who did not commit a crime are truly innocent.
    # If did_not_commit is True and innocent is unset, then set innocent to True.
    if criminal.did_not_commit is True and criminal.innocent is None:
        criminal.innocent = True

    # Premise 1: If a criminal is innocent, then they are not truly guilty.
    if criminal.innocent is True and criminal.truly_guilty is None:
        criminal.truly_guilty = False

    # Premise 3: All criminals are truly guilty or found guilty.
    # If neither truly_guilty nor found_guilty are set or True, set found_guilty to True.
    if criminal.truly_guilty is not True and criminal.found_guilty is None:
        criminal.found_guilty = True

    # Premise 4: If a criminal is found guilty, then they are sentenced.
    if criminal.found_guilty is True and criminal.sentenced is None:
        criminal.sentenced = True

    # Premise 5: If a criminal is found guilty, then they can argue against their punishment.
    if criminal.found_guilty is True and criminal.can_argue is None:
        criminal.can_argue = True

def check_conclusion(criminal: ConvictedCriminal) -> str:
    apply_premises(criminal)
    # Conclusion: Garry is not both innocent and someone who did not commit a crime.
    if criminal.innocent is True and criminal.did_not_commit is True:
        return "False"
    else:
        return "True"

def func() -> str:
    cases: List[ConvictedCriminal] = []
    # Only setting attributes related to Premise 6:
    # Case 1: Garry is not found guilty (and not sentenced)
    case1 = ConvictedCriminal(name="Garry", found_guilty=False, sentenced=False)
    cases.append(case1)
    
    # Case 2: Garry is found guilty (and therefore sentenced)
    case2 = ConvictedCriminal(name="Garry", found_guilty=True, sentenced=True)
    cases.append(case2)
    
    results = [check_conclusion(case) for case in cases]
    
    if all(r == "True" for r in results):
        return "True"
    elif all(r == "False" for r in results):
        return "False"
    else:
        return "Uncertain"

if __name__ == "__main__":
    result = func()
    print("Conclusion:", result)

</PYTHON>
Therefore, the answer is (A).
</Reasoning>
<Answer>
The final answer is (A).
</Answer>
</EXAMPLE 8>
